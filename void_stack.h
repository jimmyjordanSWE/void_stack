/**
 * @file void_stack.h
 * @brief Generic void pointer stack implementation
 * @author Jimmy Jordan
 * @date 2025
 * @version 0.1
 *
 * @warning This library is not finished, several functions are missing
 * @warning This library is not finished, several functions are missing
 * @warning This library is not finished, several functions are missing
 *
 * This library provides a simple LIFO (Last In, First Out) stack data structure
 * that can hold pointers to any data type. The stack uses void pointers, making
 * it type-agnostic, but users are responsible for managing the lifecycle and
 * type safety of the data being stored.
 *
 * @par Usage Example:
 * @code
 * #include "void_stack.h"
 *
 * // Initialize stack
 * void_stack my_stack = {NULL, 0};
 *
 * // Push data
 * int data = 42;
 * if (void_stack_push(&my_stack, &data) == VOID_STACK_SUCCESS) {
 *     printf("Push successful\n");
 * }
 *
 * // Peek at top
 * const void *top = void_stack_peek(&my_stack);
 * if (top) {
 *     printf("Top value: %d\n", *(int*)top);
 * }
 *
 * // Pop data
 * void *popped = void_stack_pop(&my_stack);
 * if (popped) {
 *     printf("Popped: %d\n", *(int*)popped);
 * }
 * @endcode
 *
 * @warning This library is not finished, several functions  are missing
 * @warning This library does not perform type checking. Users must ensure
 * type safety when casting void pointers back to their original types.
 *
 * @note The stack must be manually initialized with {NULL, 0} before first use.
 * @note Each push() calls malloc(). Each pop() calls free().
 * @note Documentation comments generated by Claude Sonnet 4 with minimal human
 * review.
 */

#ifndef VOID_STACK_H
#define VOID_STACK_H

#include <stdlib.h>

/**
 * @brief Return codes for void_stack operations
 *
 * This enumeration defines the possible return values for stack operations
 * that can fail. Success is indicated by VOID_STACK_SUCCESS (0), while
 * negative values indicate different types of errors.
 */
typedef enum {
  VOID_STACK_SUCCESS = 0,             /**< Operation completed successfully */
  VOID_STACK_ERROR_NULL_POINTER = -1, /**< NULL pointer passed as argument */
  VOID_STACK_ERROR_MEMORY = -2,       /**< Memory allocation failure */
  VOID_STACK_ERROR_EMPTY = -3         /**< Operation on empty stack */
} void_stack_result_t;

/**
 * @brief Internal node structure for the stack
 *
 * This structure represents a single node in the stack's linked list.
 * Users should not directly manipulate these nodes.
 *
 * @warning This structure is exposed for performance reasons but should
 * be considered an implementation detail. Direct manipulation may break
 * stack invariants.
 */
typedef struct {
  void *next;          /**< Pointer to the next node in the stack */
  const void *payload; /**< Pointer to the user's data */
} node;

/**
 * @brief Main stack structure
 *
 * This structure maintains the stack state including the top node
 * and current depth for O(1) size queries.
 *
 * @par Initialization:
 * Always initialize with: `void_stack my_stack = {NULL, 0};`
 */
typedef struct {
  node *head;   /**< Pointer to the top node of the stack */
  size_t depth; /**< Current number of elements in the stack */
} void_stack;

/**
 * @brief Get the current number of elements in the stack
 *
 * Returns the current depth (number of elements) in the stack.
 * This operation is O(1) as the depth is maintained internally.
 *
 * @param stack Pointer to the stack structure
 * @return Number of elements in the stack, 0 if stack is NULL or empty
 *
 * @note Returns 0 for both NULL pointer and empty stack cases.
 * Use void_stack_is_empty() if you need to distinguish between these cases.
 *
 * @par Example:
 * @code
 * void_stack my_stack = {NULL, 0};
 * printf("Stack has %zu elements\n", void_stack_get_stack_depth(&my_stack));
 * @endcode
 */
size_t void_stack_get_stack_depth(const void_stack *stack);

/**
 * @brief Push an element onto the top of the stack
 *
 * Adds a new element to the top of the stack. The payload pointer is stored
 * directly - no copy of the data is made. The caller retains ownership of
 * the data and must ensure it remains valid while on the stack.
 *
 * @param stack Pointer to the stack structure (must not be NULL)
 * @param payload Pointer to data to store (must not be NULL)
 * @return VOID_STACK_SUCCESS on success, error code on failure
 * @retval VOID_STACK_SUCCESS Operation completed successfully
 * @retval VOID_STACK_ERROR_NULL_POINTER Either stack or payload is NULL
 * @retval VOID_STACK_ERROR_MEMORY Memory allocation failed
 *
 * @warning The stack stores pointers, not copies. Ensure the pointed-to
 * data remains valid while stored in the stack.
 *
 * @par Example:
 * @code
 * void_stack my_stack = {NULL, 0};
 * char *message = "Hello World";
 *
 * void_stack_result_t result = void_stack_push(&my_stack, message);
 * if (result != VOID_STACK_SUCCESS) {
 *     fprintf(stderr, "Push failed with error %d\n", result);
 * }
 * @endcode
 */
void_stack_result_t void_stack_push(void_stack *stack, const void *payload);

/**
 * @brief Examine the top element without removing it
 *
 * Returns a pointer to the data stored in the top element of the stack
 * without removing the element. The stack remains unchanged.
 *
 * @param stack Pointer to the stack structure
 * @return Pointer to the top element's data, NULL if stack is NULL or empty
 *
 * @note The returned pointer is const to indicate that the data should not
 * be modified through this pointer while it remains on the stack.
 *
 * @warning Returns NULL for both error conditions and when the top element
 * legitimately contains NULL. Check stack depth or validity separately if
 * needed.
 *
 * @par Example:
 * @code
 * const void *top = void_stack_peek(&my_stack);
 * if (top && void_stack_get_stack_depth(&my_stack) > 0) {
 *     printf("Top element: %s\n", (char*)top);
 * }
 * @endcode
 */
const void *void_stack_peek(const void_stack *stack);

/**
 * @brief Remove and return the top element from the stack
 *
 * Removes the top element from the stack and returns the data pointer
 * that was stored in it. The caller regains full ownership of the data.
 * The stack depth is decremented by one.
 *
 * @param stack Pointer to the stack structure
 * @return Pointer to the popped element's data, NULL if stack is NULL or empty
 *
 * @note The returned pointer is no longer const since the element has been
 * removed from the stack and ownership has been transferred back to the caller.
 *
 * @warning Returns NULL for both error conditions and when the top element
 * legitimately contained NULL. Check stack depth before calling if you need
 * to distinguish these cases.
 *
 * @par Example:
 * @code
 * void *data = void_stack_pop(&my_stack);
 * if (data) {
 *     printf("Popped: %s\n", (char*)data);
 *     // Process data...
 * } else if (void_stack_get_stack_depth(&my_stack) == 0) {
 *     printf("Stack is empty\n");
 * }
 * @endcode
 */
void *void_stack_pop(void_stack *stack);

#endif /* VOID_STACK_H */